---
title: "PEC 2. Análisis de datos ómicos."
author: "Guillermo Prol Castelo"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  pdf_document:
    toc: yes
  html_document:
    theme: united
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. Abstract.





# II. Objetivos.




# III. Materiales y métodos.

## III.1. Los datos.

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE11892

https://pubmed.ncbi.nlm.nih.gov/18599741/


## III.2. Métodos.


## III.3. Librerías, directorios y funciones.

Comenzamos cargando todas las librerías que nos harán falta a lo largo del análisis.

```{r cho = T, results = 'hide'}
suppressMessages( library(Biobase) )
suppressMessages( library(GEOquery) )
suppressMessages( library(affy) )
suppressMessages( library(limma) )
suppressMessages( library(Glimma) )
suppressMessages( library(annotate) )
suppressMessages( library(annaffy) )
suppressMessages( library(gplots) )
suppressMessages( library(genefilter) )
suppressMessages( library(oligo) )
suppressMessages( library(arrayQualityMetrics) )
suppressMessages( library(ggplot2) )
suppressMessages( library(ggrepel) )
suppressMessages( library(gmodels) )
suppressMessages( library(affyQCReport) )
suppressMessages( library(edgeR) )
suppressMessages( library(RColorBrewer) )
suppressMessages( library(pasilla) )
suppressMessages( library(DESeq2) )
```

Para facilitar el estudio, trabajaremos en un directorio escogido por nosotros y cuya localización se asigna a la variable `workingDir`. Los datos se copiarán en un subdirectorio del anterior denominado `data`, que se almacenará en la variable `dataDir` y los resultados se almacenarán en un directorio `results`, cuyo nombre se almacenará en la variable `resultsDir`. También creamos la carpeta `celfiles` para guardar en ella los ficheros .CEL.

```{r}
workingDir <- getwd()
# Creamos los directorios de datos y resultados:
#system("mkdir results")
#system("mkdir celfiles")
# Los asignamos a variables:
dataDir <-file.path(workingDir, "datasets")
resultsDir <- file.path(workingDir, "results")
#celfilesDir <- file.path(workingDir,"celfiles")
# Seleccionamos el directorio de trabajo:
setwd(workingDir)
```

Cargamos las funciones necesarias para el análisis.

```{r}
# Declaramos el directorio de funciones:
functionsDir <- file.path(workingDir, "functions/")
# Cargamos la función plotPCA.R
source(file.path(functionsDir,"plotPCA.R"))
```

# IV. Resultados

## IV.1. Obtención y lectura de los datos.

```{r}
load(file.path(dataDir,"dataset4_eset.RData"))
```

```{r}
count.table <- read.table(file.path(dataDir,"dataset4_count_table.txt"), header=TRUE, sep="\t", row.names=1, quote="", comment.char="")
dim(count.table)
head(count.table)
colnames(count.table)
```

El objeto `count.table` contiene información sobre los genes (un gen por fila), cuyas  columnas contienen información sobre el número de lecturas que se alinean con el gen en cada muestra experimental.

Relación nombre de las columnas con las células analizadas (buscando en GEO):

- SRX008331: HEK293T cells rep_1
- SRX008332: HEK293T cells rep_2
- SRX008333: B cells rep_1
- SRX008334: B cells rep_2

Vamos a renombrar las columnas para saber a qué célula y repetición se refieren:

```{r}
# Cambiamos los nombres de las columnas de la tabla:
colnames(count.table) <- c("B1","B2","H1","H2")
# Vemos cómo han cambiado:
colnames(count.table)

```

Almacenamos la información del tipo de célula (B o H) en un vector `cond.type`:

```{r}
cond.type <- c("B","B","H","H")
```


## IV.2. Exploración, control de calidad y normalización.

**Filtrar**:

```{r}
## Some genes were not detected at all in these samples. We will discard them.
count.table <- count.table[rowSums(count.table) > 0,]
dim(count.table)
```

Hemos pasado de 52580 genes a 9010.


**Análisis descriptivo**:
```{r}
## Dimensions
dim(count.table)

## we can draw an histogram of all values.
col <- c("green","orange")[as.numeric(cond.type)] ## Define colors for subsequent plots
show(col)
hist(as.matrix(count.table))

## The histogram is not very informative  due to the presence of a few very high ## ## count values, that impose a very large scale onthe X axis. 
## We can use a logarithmic transformation to improve the readability. 
## Note that we will add pseudo count to avoid
## problems with "zero" counts observed for some genes in some samples. 

## Data distribution in log scale.
## Note that a pseudo count is added before logarithmic transformation
hist(as.matrix(log2(count.table + 1)),  breaks=100)

## Boxplot
boxplot(log2(count.table + 1))

## Density
## We will require one function from the affy package
#if(!require("affy")){
#  BiocManager::install("affy")
#  
#}


## Let's have a look at the scatter plots using the pairs() function
plotFun <- function(x,y){ dns <- densCols(x,y); points(x,y, col=dns, pch=".") }
pairs(log2(count.table + 1), panel=plotFun, lower.panel = NULL)
```

### IV.2.1. Control de calidad.

```{r}
library("DESeq")
## Use the newCountDataSet function to create a CountDataSet object
cds <-  newCountDataSet(count.table, cond.type )
show(cds)

## What kind of object is it ?
is(cds)
isS4(cds)

## What does it contain ?
slotNames(cds)
```


### IV.2.2. Normalización.

```{r}
### Let's implement such a function
### cds is a countDataset

estimSf <- function (cds){
    # Get the count matrix
    cts <- counts(cds)
    
    # Compute the geometric mean
    geomMean <- function(x) prod(x)^(1/length(x))

    # Compute the geometric mean over the line
    gm.mean  <-  apply(cts, 1, geomMean)
    
    # Zero values are set to NA (avoid subsequentcdsdivision by 0)
    gm.mean[gm.mean == 0] <- NA
    
    # Divide each line by its corresponding geometric mean
    # sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)
    # MARGIN: 1 or 2 (line or columns)
    # STATS: a vector of length nrow(x) or ncol(x), depending on MARGIN
    # FUN: the function to be applied
    cts <- sweep(cts, 1, gm.mean, FUN="/")
    
    # Compute the median over the columns
    med <- apply(cts, 2, median, na.rm=TRUE)
    
    # Return the scaling factor
    return(med)
    
}

  
## Normalizing with using the method for an object of class"CountDataSet" 
cds.norm <-  estimateSizeFactors(cds)
sizeFactors(cds.norm)

## Now get the scaling factor with our homemade function.cds.norm
estimSf(cds) 
round(estimSf(cds),6) == round(sizeFactors(cds.norm), 6)

## Checking the normalization
par(mfrow=c(1,2),cex.lab=0.7)
boxplot(log2(counts(cds.norm)+1),  col=col, cex.axis=0.7, las=2)
boxplot(log2(counts(cds.norm, normalized=TRUE)+1),  col=col, cex.axis=0.7, las=2) 
```


```{r}
## Performing estimation of dispersion parameter
 cds.norm <- estimateDispersions(cds.norm)

## A diagnostic plot which
## shows the mean of normalized counts (x axis)
## and dispersion estimate for each genes
plotDispEsts(cds.norm)
```


## IV.3. Selección de genes diferencialmente expresados.

### IV.3.1. 

```{r}
## Perform differential expression call
res <- nbinomTest(cds.norm, "B", "H")

## What is the object returned by nbinomTest()
is(res) # a data.frame
head(res)

## The column names of the data.frame
## Note the column padj 
## contains FDR values (computed Benjaminiâ???"Hochberg procedure)
colnames(res)

## Order the table by decreasing p-valuer
res <- res[order(res$padj),]
head(res)

```

```{r}
## We select gene names based on FDR (1%)
gene.kept <- res$id[res$padj <= 0.01 & !is.na(res$padj)]

## We retrieve the normalized counts for gene of interest
count.table.kept <- log2(count.table + 1)[gene.kept, ]
dim(count.table.kept)

## Install the gplots library if needed then load it
if(!require("gplots")){
  install.packages("gplots")
}
library("gplots")

## Perform the hierarchical clustering with
heatmap.2(as.matrix(count.table.kept), 
          scale="row", 
          hclust=function(x) hclust(x,method="average"), 
          distfun=function(x) as.dist((1-cor(t(x)))/2), 
          trace="none", 
          density="none", 
          labRow="",
          cexCol=0.7)

```

### IV.3.2. Comparaciones múltiples.


### IV.3.3. Anotación de resultados.





### IV.3.4. Visualización de los perfiles de expresión.


### IV.3.5. Análisis de significación biológica.




# V.Discusión.


