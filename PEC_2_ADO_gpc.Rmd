---
title: "PEC 2. Análisis de datos ómicos."
author: "Guillermo Prol Castelo"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  pdf_document:
    toc: yes
  html_document:
    theme: united
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# I. Abstract.





# II. Objetivos.




# III. Materiales y métodos.

## III.1. Los datos.

https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE11892

https://pubmed.ncbi.nlm.nih.gov/18599741/


## III.2. Métodos.


## III.3. Librerías, directorios y funciones.

Comenzamos cargando todas las librerías que nos harán falta a lo largo del análisis.

```{r cho = T, results = 'hide'}
suppressMessages( library(Biobase) )
suppressMessages( library(GEOquery) )
suppressMessages( library(affy) )
suppressMessages( library(limma) )
suppressMessages( library(Glimma) )
suppressMessages( library(annotate) )
suppressMessages( library(annaffy) )
suppressMessages( library(gplots) )
suppressMessages( library(genefilter) )
suppressMessages( library(oligo) )
suppressMessages( library(arrayQualityMetrics) )
suppressMessages( library(ggplot2) )
suppressMessages( library(ggrepel) )
suppressMessages( library(gmodels) )
suppressMessages( library(affyQCReport) )
suppressMessages( library(edgeR) )
suppressMessages( library(RColorBrewer) )
suppressMessages( library(pasilla) )
suppressMessages( library(DESeq2) )
suppressMessages( library(AnnotationDbi) )
suppressMessages( library(org.Hs.eg.db) )
```

Para facilitar el estudio, trabajaremos en un directorio escogido por nosotros y cuya localización se asigna a la variable `workingDir`. Los datos se copiarán en un subdirectorio del anterior denominado `data`, que se almacenará en la variable `dataDir` y los resultados se almacenarán en un directorio `results`, cuyo nombre se almacenará en la variable `resultsDir`. También creamos la carpeta `celfiles` para guardar en ella los ficheros .CEL.

```{r}
workingDir <- getwd()
# Creamos los directorios de datos y resultados:
#system("mkdir results")
#system("mkdir celfiles")
# Los asignamos a variables:
dataDir <-file.path(workingDir, "datasets")
resultsDir <- file.path(workingDir, "results")
#celfilesDir <- file.path(workingDir,"celfiles")
# Seleccionamos el directorio de trabajo:
setwd(workingDir)
```

Cargamos las funciones necesarias para el análisis.

```{r}
# Declaramos el directorio de funciones:
functionsDir <- file.path(workingDir, "functions/")
# Cargamos la función plotPCA.R
source(file.path(functionsDir,"plotPCA.R"))
```

# IV. Resultados

## IV.1. Obtención y lectura de los datos.

```{r}
load(file.path(dataDir,"dataset4_eset.RData"))
```

```{r}
count.table <- read.table(file.path(dataDir,"dataset4_count_table.txt"), header=TRUE, sep="\t", row.names=1, quote="", comment.char="")
dim(count.table)
head(count.table)
colnames(count.table)
```

El objeto `count.table` contiene información sobre los genes (un gen por fila), cuyas  columnas contienen información sobre el número de lecturas que se alinean con el gen en cada muestra experimental.

Relación nombre de las columnas con las células analizadas (buscando en GEO):

- SRX008331: HEK293T cells rep_1
- SRX008332: HEK293T cells rep_2
- SRX008333: B cells rep_1
- SRX008334: B cells rep_2

Vamos a renombrar las columnas para saber a qué célula y repetición se refieren:

```{r}
# Cambiamos los nombres de las columnas de la tabla:
colnames(count.table) <- c("B1","B2","H1","H2")
# Vemos cómo han cambiado:
colnames(count.table)

```

Almacenamos la información del tipo de célula (B o H) en un vector `cond.type`:

```{r}
cond.type <- c("B","B","H","H")
```


## IV.2. Exploración, control de calidad y normalización.

**Filtrar**:

```{r}
## Some genes were not detected at all in these samples. We will discard them.
count.table <- count.table[rowSums(count.table) > 0,]
dim(count.table)
```

Hemos pasado de 52580 genes a 9010.


**Análisis descriptivo**:
```{r}
## Dimensions
dim(count.table)

## we can draw an histogram of all values.
col <- c("green","orange")[as.numeric(cond.type)] ## Define colors for subsequent plots
show(col)
hist(as.matrix(count.table))

## The histogram is not very informative  due to the presence of a few very high ## ## count values, that impose a very large scale onthe X axis. 
## We can use a logarithmic transformation to improve the readability. 
## Note that we will add pseudo count to avoid
## problems with "zero" counts observed for some genes in some samples. 

## Data distribution in log scale.
## Note that a pseudo count is added before logarithmic transformation
hist(as.matrix(log2(count.table + 1)),  breaks=100)

## Boxplot
boxplot(log2(count.table + 1))

## Density
## We will require one function from the affy package
#if(!require("affy")){
#  BiocManager::install("affy")
#  
#}


## Let's have a look at the scatter plots using the pairs() function
plotFun <- function(x,y){ dns <- densCols(x,y); points(x,y, col=dns, pch=".") }
pairs(log2(count.table + 1), panel=plotFun, lower.panel = NULL)
```

**Counts to DGEList**:

```{r}
y <- DGEList(count.table)
# have a look at y
y
# See what slots are stored in y
names(y)
# Library size information is stored in the samples slot
y$samples
```


### IV.2.1. Control de calidad.

**Library sizes and distribution plots**:

```{r}
y$samples$lib.size
```

```{r}
# The names argument tells the barplot to use the sample names on the x-axis
# The las argument rotates the axis names
barplot(y$samples$lib.size,names=colnames(y),las=2)
# Add a title to the plot
title("Barplot of library sizes")
```

```{r}
# Get log2 counts per million
logcounts <- cpm(y,log=TRUE)
# Check distributions of samples using boxplots
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
title("Boxplots of logCPMs (unnormalised)")
```

**Multidimensional scaling plots**:

```{r}
plotMDS(y,col=c("purple","purple", "orange", "orange"))
```

**Hierarchical clustering with heatmaps**:

```{r}
# We estimate the variance for each row in the logcounts matrix
var_genes <- apply(logcounts, 1, var)
head(var_genes)
# Get the gene names for the top 500 most variable genes
select_var <- names(sort(var_genes, decreasing=TRUE))[1:500]
head(select_var)
# Subset logcounts matrix
highly_variable_lcpm <- logcounts[select_var,]
dim(highly_variable_lcpm)
head(highly_variable_lcpm)

## Get some nicer colours
mypalette <- brewer.pal(11,"RdYlBu")
morecols <- colorRampPalette(mypalette)
# Set up colour vector for celltype variable
col.cell <- c("purple","purple","orange","orange")

# Plot the heatmap
heatmap.2(highly_variable_lcpm,col=rev(morecols(50)),trace="none", main="Top most variable genes across samples",ColSideColors=col.cell,scale="row")
```




______________________________

```{r}
library("DESeq")
## Use the newCountDataSet function to create a CountDataSet object
cds <-  newCountDataSet(count.table, cond.type )
show(cds)

## What kind of object is it ?
is(cds)
isS4(cds)

## What does it contain ?
slotNames(cds)
```


### IV.2.2. Normalización.

```{r}
# Apply normalisation to DGEList object
y <- calcNormFactors(y)
```

```{r}
y$samples
```

```{r}
par(mfrow=c(1,2))
plotMD(logcounts,column = 1)
abline(h=0,col="grey")
plotMD(logcounts,column = 3)
abline(h=0,col="grey")
```

```{r}
par(mfrow=c(1,2))
plotMD(y,column = 1)
abline(h=0,col="grey")
plotMD(y,column = 3)
abline(h=0,col="grey")
```





__________________________
```{r}
### Let's implement such a function
### cds is a countDataset

estimSf <- function (cds){
    # Get the count matrix
    cts <- counts(cds)
    
    # Compute the geometric mean
    geomMean <- function(x) prod(x)^(1/length(x))

    # Compute the geometric mean over the line
    gm.mean  <-  apply(cts, 1, geomMean)
    
    # Zero values are set to NA (avoid subsequentcdsdivision by 0)
    gm.mean[gm.mean == 0] <- NA
    
    # Divide each line by its corresponding geometric mean
    # sweep(x, MARGIN, STATS, FUN = "-", check.margin = TRUE, ...)
    # MARGIN: 1 or 2 (line or columns)
    # STATS: a vector of length nrow(x) or ncol(x), depending on MARGIN
    # FUN: the function to be applied
    cts <- sweep(cts, 1, gm.mean, FUN="/")
    
    # Compute the median over the columns
    med <- apply(cts, 2, median, na.rm=TRUE)
    
    # Return the scaling factor
    return(med)
    
}

  
## Normalizing with using the method for an object of class"CountDataSet" 
cds.norm <-  estimateSizeFactors(cds)
sizeFactors(cds.norm)

## Now get the scaling factor with our homemade function.cds.norm
estimSf(cds) 
round(estimSf(cds),6) == round(sizeFactors(cds.norm), 6)

## Checking the normalization
par(mfrow=c(1,2),cex.lab=0.7)
boxplot(log2(counts(cds.norm)+1),  col=col, cex.axis=0.7, las=2)
boxplot(log2(counts(cds.norm, normalized=TRUE)+1),  col=col, cex.axis=0.7, las=2) 
```


```{r}
## Performing estimation of dispersion parameter
 cds.norm <- estimateDispersions(cds.norm)

## A diagnostic plot which
## shows the mean of normalized counts (x axis)
## and dispersion estimate for each genes
plotDispEsts(cds.norm)
```


## IV.3. Selección de genes diferencialmente expresados.

### IV.3.1. Análisis basado en modelos lineales.

**Matriz de diseño**.

```{r}
# Look at group variable again
group <- cond.type
group
```
```{r}
# Specify a design matrix without an intercept term
design <- model.matrix(~ 0 + group)
colnames(design) <- c("B","H")
design
```

**Voom transform the data**:

```{r}
par(mfrow=c(1,1))
v <- voom(y,design,plot = TRUE)
```

```{r}
v
```

```{r}
par(mfrow=c(1,2))
boxplot(logcounts, xlab="", ylab="Log2 counts per million",las=2,main="Non normalised logCPM")
## Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(logcounts),col="blue")
boxplot(v$E, xlab="", ylab="Log2 counts per million",las=2,main="Voom transformed logCPM")
## Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(v$E),col="blue")
```






**Matriz de contrastes**:

```{r}
cont.matrix <- makeContrasts(Cell=B-H,levels=design)
cont.matrix
```

### IV.3.2. Comparaciones múltiples.

**Testing for differential expression**:

```{r}
# Fit the linear model
fit <- lmFit(v)
names(fit)
```

```{r}
fit.cont <- contrasts.fit(fit, cont.matrix)
fit.cont <- eBayes(fit.cont)

summa.fit <- decideTests(fit.cont)
summary(summa.fit)
```

```{r}
topTable(fit.cont,coef=1,sort.by="p")
```


### IV.3.3. Anotación de resultados.

Genome wide annotation for Human:

```{r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("org.Hs.eg.db")
```

```{r}
library(org.Hs.eg.db)
```

```{r}
columns(org.Hs.eg.db)
```

```{r}
example <- as.character(as.numeric(substr(rownames(fit.cont),start=5,stop=15)))
ann <- select(org.Hs.eg.db,keys=example,columns=c("ENTREZID","SYMBOL","GENENAME"))
head(ann)
```

```{r}
table(ann$ENTREZID==example)
```

```{r}
fit.cont$genes <- ann
topTable(fit.cont,coef=1,sort.by="p")
```

```{r}
limma.res <- topTable(fit.cont,coef=1,sort.by="p",n=100)
write.csv(limma.res,file=file.path(resultsDir,"annotation_results.csv"),row.names=FALSE)
```

**Plots after testing for DE (Volcano plot,MAplot)**:

```{r}
# We want to highlight the significant genes. We can get this from decideTests.
par(mfrow=c(1,2))
plotMD(fit.cont,coef=1,status=summa.fit[,1], values = c(-1, 1))

# For the volcano plot we have to specify how many of the top genes to highlight.
# We can also specify that we want to plot the gene symbol for the highlighted genes.
# let's highlight the top 100 most DE genes
volcanoplot(fit.cont,coef=1,highlight=100,names=fit.cont$genes$SYMBOL)
```

### IV.3.4. Análisis de significación biológica.

```{r}
require(GOstats)
```

```{r}
require(org.Hs.eg.db)

 
   # Seleccionamos la "topTable"
   topTab <- topTable(fit.cont,coef=1,sort.by="p")
   # Definimos el universo de genes: todos los que se han incluido en el analisis
   # EL programa trabaja con identificadores "entrez" y no admite duplicados
 
   entrezUniverse <- unique(getEG(as.character(rownames(topTab)), "org.Hs.eg.db"))
 
   # Filtramos posibles NA:
   entrezUniverse <- entrezUniverse[!is.na(entrezUniverse)]
   
   # Escogemos los grupos de sondas a incluir en el analisis
   # Este analisis trabaja bien con varios centenares de genes
   # por lo que es habitual basarse en p-valores sin ajustar para incluirlos
 
   whichGenes<-topTab["adj.P.Val"]<0.001
   geneIds <-   unique(getEG(as.character(rownames(topTab)[whichGenes[,1]]),"org.Hs.eg.db"))
 
   # Filtramos posibles NA:
   geneIds <- geneIds[!is.na(geneIds)]
   
   # Creamos los "hiperparametros" en que se basa el analisis
   GOparams = new("GOHyperGParams",
     geneIds=geneIds, universeGeneIds=entrezUniverse,
     annotation="org.Hs.eg.db", ontology="BP",
     pvalueCutoff=0.001, conditional=FALSE,
     testDirection="over")
   KEGGparams = new("KEGGHyperGParams",
     geneIds=geneIds, universeGeneIds=entrezUniverse,
     annotation="org.Hs.eg.db",
     pvalueCutoff=0.01, testDirection="over")
 
   # Ejecutamos los analisis
 
   GOhyper = hyperGTest(GOparams)
   KEGGhyper = hyperGTest(KEGGparams)
 
 # Creamos un informe html con los resultados
    comparison = "Diet"
    GOfilename =file.path(resultsDir,
      paste("GOResults.",comparison,".html", sep=""))
    KEGGfilename =file.path(resultsDir,
      paste("KEGGResults.",comparison,".html", sep=""))
   htmlReport(GOhyper, file = GOfilename, summary.args=list("htmlLinks"=TRUE))
   htmlReport(KEGGhyper, file = KEGGfilename, summary.args=list("htmlLinks"=TRUE))
```


# V.Discusión.


